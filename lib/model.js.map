{"version":3,"sources":["lib/model.ts"],"names":[],"mappings":";;AACA,iCAAwC;AAE3B,QAAA,aAAa,GAAmD,UAAC,IAA4B;IACtG,OAAO,CAAC,GAAG,CAAC,oFAAoF,CAAC,CAAC;IAClG,MAAM,IAAI,uBAAe,CAAC,wBAAwB,CAAC,CAAC;AACxD,CAAC,CAAC;AAEF;;GAEG;AACH;IAKI,oBAAY,GAAiC,EAAE,IAA6B;QACxE,IAAI,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,qBAAa,CAAC;QACvC,IAAI,CAAC,IAAI,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC;IACnC,CAAC;IACL,iBAAC;AAAD,CATA,AASC,IAAA;AATY,gCAAU","file":"model.js","sourcesContent":["import * as seneca from \"seneca\";\r\nimport {ServerPlumError} from \"./error\";\r\n\r\nexport const invalidActFun: (args: { [key: string]: any }) => Promise<any> = (args: { [key: string]: any }): Promise<any> => {\r\n    console.log(\"[Microplum] '.act' not set in the service entity. Please use setAct method before.\");\r\n    throw new ServerPlumError(\"'act' service not set.\");\r\n};\r\n\r\n/**\r\n * Facade class that can be extended with specific methods.\r\n */\r\nexport class PlumFacade implements HasAct {\r\n\r\n    public act: (args: { [key: string]: any }) => Promise<any>;\r\n    public args: { [key: string]: any };\r\n\r\n    constructor(act?: (args: any) => Promise<any>, args?: { [key: string]: any }) {\r\n        this.act = (act) ? act : invalidActFun;\r\n        this.args = (args) ? args : {};\r\n    }\r\n}\r\n\r\nexport interface DefaultConfig {\r\n    version?: number;\r\n    subversion?: number,\r\n    revision?: number,\r\n    environment?: string;\r\n    pin?: string[];\r\n    clientPin?: string;\r\n    seneca?: seneca.Options;\r\n}\r\n\r\nexport interface Config extends DefaultConfig {\r\n    app: string;\r\n    /**\r\n     * Available roles in the act method\r\n     */\r\n    roles: string[];\r\n    provider?: string;\r\n    amqpUrl: string;\r\n    debugUserId?: string;\r\n}\r\n\r\nexport interface Microplum {\r\n\r\n    /**\r\n     * Close the connection. Use it before exiting the app.\r\n     */\r\n    close(): void;\r\n\r\n    /**\r\n     * Listen app trigger os selected configuration.\r\n     */\r\n    listen(): void;\r\n\r\n    /**\r\n     * Set-up seneca connection for calls.\r\n     */\r\n    client(): void;\r\n\r\n    use(component: Function, pin?: any): void;\r\n\r\n    useService(service: Entity, pin?: any): void\r\n\r\n    add(pin: any, cb: Function): void;\r\n\r\n    act(pin: any, respond: seneca.ActCallback): void;\r\n    actPromise(pin: any, user?: any): Promise<any>;\r\n\r\n}\r\n\r\nexport interface Entity {\r\n\r\n    /**\r\n     * Module seneca service definition.\r\n     * @param options\r\n     * @return seneca plugin\r\n     */\r\n    plugin(): Function;\r\n\r\n    publicPin(): any;\r\n    setAct(act: Function): void;\r\n    getAct(user?: any): Function;\r\n\r\n}\r\n\r\n/**\r\n * Basic entity of the facade with the _id (optional) field.\r\n */\r\nexport interface FacadeEntity {\r\n    _id?: string;\r\n}\r\n\r\n/**\r\n * Entity that are able to sync with another systems - has field for links and sync table\r\n */\r\nexport interface SyncEntity {\r\n    _sync: string;\r\n    _link: string;\r\n}\r\n\r\n/**\r\n * Interface that saus the object has reference to the act method.\r\n */\r\nexport interface HasAct {\r\n    act: (args: any) => Promise<any>;\r\n}\r\n\r\nexport interface SeedFacade extends PlumFacade {\r\n    seed?(): Promise<void>;\r\n    reset?(doSeed: boolean): Promise<void>;\r\n}\r\n\r\n/**\r\n * Facade interface for the entity manipulation (CRUD+List). All the methods form the interface are optional.\r\n * All the methods are async\r\n */\r\nexport interface RestFacade<E extends FacadeEntity> extends PlumFacade {\r\n    /**\r\n     * Create new entity with the selected input\r\n     * @param input\r\n     * @param syncId null if needs to sync, id if it's already synced\r\n     * @return created entity\r\n     */\r\n    create?(input: E, syncId?: string | null): Promise<E>;\r\n    /**\r\n     * Update all the entity for selected condition with selected update\r\n     * @param conditions\r\n     * @param update\r\n     * @param syncId null if needs to sync, id if it's already synced\r\n     * @return updated entity\r\n     */\r\n    update?(conditions: { [key: string]: any }, update: { [key: string]: any }, syncId?: string | null): Promise<E[]>;\r\n    /**\r\n     * Update all the entity for selected condition with selected update\r\n     * @param conditions\r\n     * @param update\r\n     * @param syncId null if needs to sync, id if it's already synced\r\n     * @return updated entity\r\n     */\r\n    updateOne?(conditions: { [key: string]: any }, update: { [key: string]: any }, syncId?: string | null): Promise<E | null>;\r\n    /**\r\n     * Update all the entity for selected condition with selected update\r\n     * @param id\r\n     * @param update\r\n     * @param syncId null if needs to sync, id if it's already synced\r\n     * @return updated entity\r\n     */\r\n    updateById?(id: string, update: { [key: string]: any }, syncId?: string | null): Promise<E | null>;\r\n    /**\r\n     * Find the list of the entities for selected query\r\n     * @param query (default all)\r\n     * @return list of the entity\r\n     */\r\n    find?(query?: { [key: string]: any }): Promise<E[]>;\r\n    /**\r\n     * Find first entity for selected query\r\n     * @param query (default all)\r\n     * @return fist entity or null\r\n     */\r\n    findOne?(query?: { [key: string]: any }): Promise<E | null>;\r\n    /**\r\n     * Find entity by the id\r\n     * @param id\r\n     * @return found entity or null\r\n     */\r\n    findById?(id: string): Promise<E | null>;\r\n    /**\r\n     * Remove entity by the id\r\n     * @param query\r\n     * @param syncId null if needs to sync, id if it's already synced\r\n     * @return removed entity or null\r\n     */\r\n    remove?(query?: { [key: string]: any }): Promise<E[]>;\r\n    /**\r\n     * Remove entity by the id\r\n     * @param id\r\n     * @param syncId null if needs to sync, id if it's already synced\r\n     * @return removed entity or null\r\n     */\r\n    removeOne?(query?: { [key: string]: any }): Promise<E | null>;\r\n    /**\r\n     * Remove entity by the id\r\n     * @param id\r\n     * @param syncId null if needs to sync, id if it's already synced\r\n     * @return removed entity or null\r\n     */\r\n    removeById?(id: string): Promise<E | null>;\r\n    /**\r\n     * Remove all the entities for selected query\r\n     * @param syncId null if needs to sync, id if it's already synced\r\n     * @param query (default all)\r\n     */\r\n    clean?(query?: { [key: string]: any }): Promise<E[]>;\r\n    /**\r\n     * Count the objects in the storage based on the query.\r\n     * @param query\r\n     */\r\n    count?(query?: { [key: string]: any }): Promise<number>;\r\n}\r\n"]}